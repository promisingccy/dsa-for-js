# dsa-for-js
Data structure and algorithms for JS version.


#### js shell环境搭建
https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/

https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/jsshell-win64.zip


==================== 第一章 环境-js shell

-运行代码
```
->js
js>1+3
4
js>
```

-运行文件
```
->js demo1.js
```


-退出jsshell
```
js>quit()
```

-判断结构
```
	if
	switch
```


-循环结构
```
	while
	for
```

-函数
```
	有返回值
	无返回值（子程、void函数）
```


==================== 数组 array
```
==== 添加元素
	arr.push(6);//将元素添加到末尾
	arr.unshift(new);//将new元素添加到开头

==== 删除元素
	arr.pop();//删除数组末尾的元素
	arr.shift();//删除数组第一个元素

==== 从中间位置添加/删除元素
	arr.splice(start, del_nums);//删除
	arr.splice(start, del_nums, new_elem);//添加

var nums = [1,2,5,6];
nums.splice(2, 0, [3,4]);
print(nums);//1,2,3,4,5,6


==== 排序
	arr.reseerve();//倒序翻转
	arr.sort();//按字符大小排序

var nums = [5, 65, 10, 88, 101];
function compare(n1, n2){
	return n1-n2;
}
nums.sort(compare);//实现了sort()的数字排序
print(nums);//5,10,65,88,101


==== 迭代
	arr.forEach(func);//将arr每个元素都进行func操作
	var bool = arr.every(bool_func);//都进行func操作，都true则返回true
	var bool = arr.some(bool_func);//都进行func操作，只要有true则返回true
	arr.reduce(func);
	arr.reduceRight(func);

	arr.map(func);
	filter();

- map()和forEach()有点儿像，对数组中的每个元素使用某个函数。 两者的区别是 map() 返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。

-filter() 和 every() 类似， 传入一个返回值为布尔类型的函数。 和 every() 方法不同的是，当对数组中的所有元素应用该函数， 结果均为 true 时， 该方法并不返回 true， 而是返回一个新数组， 该数组包含应用该函数后结果为 true 的元素。 
```


==================== 列表 list
```
==== 列表的抽象数据类型定义
listSize（属性）--------列表的元素个数
pos（属性）-------------列表的当前位置
length（属性）----------返回列表中元素的个数

append（方法）----------在列表的末尾添加新元素
remove（方法）----------从列表中删除元素
toString（方法）--------返回列表的字符串形式

insert（方法）----------在现有元素后插入新元素
clear（方法）-----------清空列表中的所有元素

front（方法）-----------将列表的当前位置移动到第一个元素
end（方法）-------------将列表的当前位置移动到最后一个元素
prev（方法）------------将当前位置前移一位
next（方法）------------将当前位置后移一位
currPos（方法）---------返回列表的当前位置
moveTo（方法）----------将当前位置移动到指定位置
getElement（方法）------返回当前位置的元素


==== 使用迭代器访问列表
- 访问列表元素时不必关心底层的数据存储结构。
- 当为列表添加一个元素时，索引的值就不对了，此时只用更新列表，而不用更新迭代器。
- 可以用不同类型的数据存储方式实现List类，迭代器为访问列表里的元素提供了一种统一的方式。

```


==================== 栈 stack
```
- 栈是一种特殊的列表， 栈内的元素只能通过列表的一端访问， 这一端称为栈顶。
- 咖啡厅内的一摞盘子是现实世界中常见的栈的例子。 只能从最上面取盘子， 盘子洗净后， 也只能摞在这一摞盘子的最上面。 
- 栈被称为一种后入先出（LIFO， last-in-first-out） 的数据结构。

==== 栈的抽象数据类型定义

length------------（属性）记录栈内元素的个数
empty-------------（属性）表示栈内是否含有元素

push()------------（方法）将一个元素压入栈
pop()-------------（方法）将一个元素弹出栈
peek()------------（方法）返回栈顶元素
clear()-----------（方法）清除栈内所有元素 
```


==================== 队列 Queue
```
- 队列是一种列表， 不同的是队列只能在队尾插入元素， 在队首删除元素。 
- 队列用于存储按顺序排列的数据，先进先出，这点和栈不一样，在栈中，最后入栈的元素反而被优先处理。 
- 在银行前排队的人群，排在最前面的人第一个办理业务，新来的人只能在后面排队， 直到轮到他们为止。

==== 队列的抽象数据类型定义

dataStore------------（属性）底层数据结构-数组

length---------------（方法）返回队列长度
enqueue--------------（方法）向队尾添加一个元素
dequeue--------------（方法）删除队首的元素
front----------------（方法）返回队首的元素
back-----------------（方法）返回队尾的元素
toString-------------（方法）显示队列内的所有元素
empty----------------（方法）判断队列是否为空

```


==================== 链表 LinkedList
```
====数组的缺点

数组不总是组织数据的最佳数据结构， 原因如下：
	在很多编程语言中， 数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。
	在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了
添加或删除操作。

然而，JavaScript 的数组并不存在上述问题，因为使用 split() 方法不需要再访问数组中的其他元素了。JavaScript 中数组的主要问题是， 它们被实现成了对象，与其他语言（比如 C++ 和 Java）的数组相比，效率很低。

如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中。 如果需要随机访问， 数组仍然是更好的选择。


==== 定义链表
	链表是由一组节点组成的集合。
	每个节点都使用一个对象的引用指向它的后继。
	指向另一个节点的引用叫做链。
	链表的头节点常常用来作为链表的接入点。
	链表的尾元素指向一个 null 节点。

数组元素靠它们的位置进行引用，链表元素则是靠相互之间的关系进行引用。 
遍历链表，就是跟着链接，从链表的首元素一直走到尾元素（但这不包含链表的头节点， 头节点常常用来作为链表的接入点）。
然而要标识出链表的起始节点却有点麻烦，许多链表的实现都在链表最前面有一个特殊节点，叫做头节点。 

==== 链表的操作
新增：链表中插入一个节点的效率很高。向链表中插入一个节点，需要修改它前面的节点（前驱），使其指向新加入的节点，而新加入的节点则指向原来前驱指向的节点。

删除：从链表中删除一个元素也很简单。将待删除元素的前驱节点指向待删除元素的后继节点，同时将待删除元素指向null，元素就删除成功了。 


======== 链表的抽象数据类型定义
设计的链表包含两个类。 
	Node 类用来表示节点
	LinkedList 类提供了插入节点、删除节点、显示列表元素的方法 以及其他一些辅助方法

==== Node类
Node 类包含两个属性： 
	element 用来保存节点上的数据
	next 用来保存指向下一个节点的链接。 
我们使用一个构造函数来创建节点， 该构造函数设置了这两个属性的值：
function Node(element) {
	this.element = element;
	this.next = null;
}

element-----------（属性）节点上的数据
next--------------（属性）指向下一个节点的链接


==== LList类
head-----------（属性）头结点
find-----------（方法）查找节点
insert---------（方法）插入节点
findPrevious---（方法）查找当前节点的上一节点
remove---------（方法）删除节点
display--------（方法）打印链表

advance(n)-----（方法）在链表中向前移动 n 个节点。
back(n)--------（方法）在双向链表中向后移动 n 个节点
show(n)--------（方法）只显示当前节点的数据

==== 链表的种类
单向链表LList
双向链表SXLList
循环链表XHLList


==== ???????????????????????
advance(n)-----（方法）在链表中向前移动 n 个节点。
back(n)--------（方法）在双向链表中向后移动 n 个节点
约瑟夫环？

```

==================== 字典
```
字典是一种以键-值对形式存储数据的数据结构，就像电话号码簿里的名字和电话号码一样。要找一个电话时，先找名字，名字找到了，紧挨着它的电话号码也就找到了。这里键是指你用来查找的东西，值是查找得到的结果。

JavaScript的Object类就是以字典的形式设计的。将使用 Object 类本身的特性，实现一个 Dictionary 类

==== Dictionary类
-Dictionay类的基础是Array类，而不是Object类。

-从字典中删除键 - 值对需要使用 JavaScript 中的一个内置函数：delete。 该函数是 Object类的一部分， 使用对键的引用作为参数。 该函数同时删掉键和与其关联的值。 

==================== 散列
散列是一种常用的数据存储技术， 散列后的数据可以快速地插入或取用。 散列使用的数据结构叫做散列表。 在散列表上插入、 删除和取用数据都非常快， 但是对于查找操作来说却效率低下， 比如查找一组数据中的最大值和最小值。 这些操作得求助于其他数据结构， 二叉查找树就是一个很好的选择。 

使用散列表存储数据时， 通过一个散列函数将键映射为一个数字， 这个数字的范围是 0 到散列表的长度。理想情况下， 散列函数会将每个键值映射为一个唯一的数组索引。 然而， 键的数量是无限的， 数组的长度是有限的（理论上， 在 JavaScript 中是这样）， 一个更现实的目标是让散列函数尽量将键均匀地映射到数组中。

即使使用一个高效的散列函数， 仍然存在将两个键映射成同一个值的可能， 这种现象称为碰撞（collision）。
```

==================== 集合


==================== 二叉树和二叉查找树
```
树是计算机科学中经常用到的一种数据结构。
树是一种非线性的数据结构， 以分层的方式存储数据。 树被用来存储具有层级关系的数据， 比如文件系统中的文件；树还被用来存储有序列表。 

选择树而不是那些基本的数据结构， 是因为在二叉树上进行查找非常快（而在链表上查找则不是这样），为二叉树添加或删除元素也非常快（而对数组执行添加或删除操作则不是这样）。


======== 树的基本概念

-树的路径：沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节点。 从一个节点到另一个节点的这一组边称为路径

-树的遍历：以某种特定顺序访问树中所有的节点称为树的遍历。

-树的层次：树可以分为几个层次， 
	根节点是第 0 层， 
	它的子节点是第 1 层， 
	子节点的子节点是第 2层，
	...

-树的深度：树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节点， 子节点的子节点等。我们定义树的层数就是树的深度。

-树的表示：这种自上而下的树与人们的直觉相反。现实世界里，树的根是在底下的。在计算机科学里，自上而下的树则是个由来已久的习惯。 

-节点的值/键：每个节点都有一个与之相关的值，该值有时被称为键。

-一个父节点的两个子节点分别称为左节点和右节点。



======== 二叉树BST和二叉查找树

二叉树查找（BST）:为了方便查找一组数据中的最小值和最大值。

二叉树BST是一种特殊的树， 它的子节点个数不超过两个。二叉树具有一些特殊的计算性质，使得在它们之上的一些操作异常高效。

二叉查找树是一种特殊的二叉树：
	较小的值保存在左节点中
	较大的值保存在右节点中
这一特性使得查找的效率很高，对于数值型和非数值型的数据， 比如单词和字符串， 都是如此。


有三种遍历 BST 的方式：
这里的 “前中后” 指的是 “父节点” 在三者间的位置（左在右前）
中序：左->父->右
先序：父->左->右
后序：左->右->父

```

==================== 图和图算法
```
==== 基本概念

-图：图由边的集合及顶点的集合组成。 
看看地图， 每两个城镇都由某种道路相连。地图，就是一种图，上面的每个城镇可以看作一个顶点， 连接城镇的道路便是边。

-边：边由顶点对 (v1,v2) 定义， v1 和 v2 分别是图中的两个顶点。
-顶点：顶点也有权重， 也称为成本。 
-有向图：如果一个图的顶点对是有序的， 则可以称之为有向图。 
在对有向图中的顶点对排序后， 便可以在两个顶点之间绘制一个箭头。
有向图表明了顶点的流向。计算机程序中用来表明计算方向的流程图就是一个有向图的例子。

-路径：图中的一系列顶点构成路径，路径中所有的顶点都由边连接。
-路径的长度：路径的长度 用路径中 第一个顶点到最后一个顶点之间 边的数量 表示。

-环：由指向自身的顶点组成的路径称为环，环的长度为 0。

-圈：圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。
-简单圈：无论是有向图还是无向图，只要是没有重复边或重复顶点的圈，就是一个 简单圈。 
-平凡圈：除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈称为 平凡圈。
-强连通的顶点：如果两个顶点之间有路径， 那么这两个顶点就是强连通的， 反之亦然。
-强连通的有向图：如果有向图的所有的顶点都是强连通的，那么这个有向图也是强连通的。

==== 边
-图的实际信息都保存在边上面

-将表示图的边的方法称为 邻接表 或者 邻接表数组
这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。使用这种方案，当我们在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表。 

另一种表示图边的方法被称为邻接矩阵。它是一个二维数组，其中的元素表示两个顶点之间是否有一条边。

==== 搜索图
确定从一个指定的顶点可以到达其他哪些顶点，这是经常对图执行的操作。
我们可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。图上的这些操作是用搜索算法执行的。 

在图上可以执行两种基础搜索：
	深度优先搜索
	广度优先搜索

-深度优先搜索
深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。 

深度优先搜索算法比较简单：访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。

-广度优先搜索
广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。

```


==================== 排序算法
==================== 检索算法
==================== 高级算法



-代码下载
https://github.com/oreillymedia/data_structures_and_algorithms_using_javascript